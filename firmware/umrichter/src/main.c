/*
 ******************************************************************************
 File:     main.c
 Info:     Generated by Atollic TrueSTUDIO(R) 9.0.1   2018-06-29

 The MIT License (MIT)
 Copyright (c) 2018 STMicroelectronics

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 ******************************************************************************
 */

/*
 * Autor: am
 * Beschreibung: Mann kann Htl oder PWM-modulierte Signale produzieren. Die Genauikeit ist sehr begrenzt, da
 * 				 man diskreten Timer-Werten statt Float arbeitet und kann nicht die Frequenzen mit Nachkommastellen darstellen.
 * 				 Zudem bei 16Khz lassen sich die Frequenz noch ungenauer darstellen, wegen dem Konzept wie die Ansteuerung aufgebaut ist.
 *
 * 				 Sonst Verschriebung, Amplitude und Offset sind einstellbar.
 *
 * */

/* Includes */
#include "globals.h"
#include "table.h"

#define VERSION "2021-10-11"

/**/
#define INCREMENT_MULTIPLIER  0x7FFFF
#define NUM_OF_INCREMENTS (uint32_t) (mTotalNumberOfValues*INCREMENT_MULTIPLIER)

/* Global File Variables */
#define dSelectSine   0
#define dSelectTriangle 1

/* Types*/
enum ERRORS {
	ERROR_NONE = 0, ERROR_TIMEOUT = 1, ERROR_LENGTH = 2, ERROR_COMMAND = 3, ERROR_UNKNOWN = 0xFF
};

// Please add to the list according to the parsers switchcase
enum COMMANDS {
	INIT = 0, RECEIVE = 1, VALIDATE = 2, CLEANUP = 3, ERRORUP = 4, CMD_SET_FREQUENCIES = 0x0009, CMD_SET_AMPOFFSETS = 0x000A, CMD_SET_SHIFTS = 0x000B, CMD_MODE = 0x0020, CMD_SET_ALL = 0x0030, CMD_GET_ALL = 0x0031
};

extern Configuration_t stcGlobalConfiguration;
extern RuntimeData_t stcGlobalRuntimeData;

// Signal type
static uint8_t ui8SelectSignalType = dSelectSine;

// Uart timeout
static uint16_t ui16gUartTimeout = 0;

// Debug
uint32_t ui32DebugCounter = 0;
uint32_t ui32DebugIndex = 0;
uint32_t ui32DebugArray[1000];

/* Setup Pwm */
static void vSetupPwm() {
	TIM1->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
	TIM1->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
	TIM1->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);

	switch (stcGlobalConfiguration.ui8SignalStateU) {
	case SIGNAL_STATE_FREQ:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x0FF8F)) | (TIM_OCMode_PWM1);
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x0FF8F)) | (TIM_ForcedAction_Active);
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x0FF8F)) | (TIM_ForcedAction_InActive);
		break;
	}

	switch (stcGlobalConfiguration.ui8SignalStateV) {
	case SIGNAL_STATE_FREQ:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x08FFF)) | (TIM_OCMode_PWM1 << 8);
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x08FFF)) | (TIM_ForcedAction_Active << 8);
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCMR1 = (TIM1->CCMR1 & (0x08FFF)) | (TIM_ForcedAction_InActive << 8);
		break;
	}

	switch (stcGlobalConfiguration.ui8SignalStateW) {
	case SIGNAL_STATE_FREQ:
		TIM1->CCMR2 = (TIM1->CCMR2 & (0x0FF8F)) | (TIM_OCMode_PWM1);
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCMR2 = (TIM1->CCMR2 & (0x0FF8F)) | (TIM_ForcedAction_Active);
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCMR2 = (TIM1->CCMR2 & (0x0FF8F)) | (TIM_ForcedAction_InActive);
		break;
	}

	TIM1->CCMR1 &= ~(TIM_CCMR1_OC1PE | TIM_CCMR1_OC2PE);		// Synchronize preloading CCR  on the update event
	TIM1->CCMR2 &= ~(TIM_CCMR2_OC3PE);

	// Offsets
	stcGlobalRuntimeData.ui16BottomOffsetU = stcGlobalConfiguration.ui16SignalOffsetU * TIM_PERIOD_PWM / 100;
	stcGlobalRuntimeData.ui16BottomOffsetV = stcGlobalConfiguration.ui16SignalOffsetV * TIM_PERIOD_PWM / 100;
	stcGlobalRuntimeData.ui16BottomOffsetW = stcGlobalConfiguration.ui16SignalOffsetW * TIM_PERIOD_PWM / 100;

	// Shifts
	stcGlobalRuntimeData.ui16ShiftU = stcGlobalConfiguration.ui16SignalShiftU * mTotalNumberOfValues / 360;
	stcGlobalRuntimeData.ui16ShiftV = stcGlobalConfiguration.ui16SignalShiftV * mTotalNumberOfValues / 360;
	stcGlobalRuntimeData.ui16ShiftW = stcGlobalConfiguration.ui16SignalShiftW * mTotalNumberOfValues / 360;
}

/*------------
 *  1  |  2  |
 *     |     |
 *------------
 * */
static void vSetupHtl() {
	Configuration_t *pconfiguration = &stcGlobalConfiguration;
	uint32_t ui32TempCcVal0 = 0;
	uint32_t ui32TempCcVal1 = 0;
	uint32_t ui32TempCcVal2 = 0;

	uint16_t ui16Counter = TIM1->CNT;
	uint16_t ui16PortE = GPIOE->IDR;

	uint8_t ui8Ccr1triggered = ((TIM1->CCR1 <= ui16Counter));
	uint8_t ui8Ccr2triggered = ((TIM1->CCR2 <= ui16Counter));
	uint8_t ui8Ccr3triggered = ((TIM1->CCR3 <= ui16Counter));

	TIM1->SR &= ~TIM_SR_UIF;
	TIM1->CR2 &= (0x0F);	// Clear Inactive

	// Signal U

	//TIM1->CCER |= (TIM_CCER_CC1P | TIM_CCER_CC1NP);

	switch (pconfiguration->ui8SignalStateU) {
	case SIGNAL_STATE_FREQ:
		if (pconfiguration->ui16SignalShiftU > 180) {
			ui32TempCcVal0 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftU - 180) / 180;
			TIM1->CCER |= (TIM_CCER_CC1P | TIM_CCER_CC1NP);
		} else {
			TIM1->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
			ui32TempCcVal0 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftU) / 180;
		}

		TIM1->CCMR1 = (TIM1->CCMR1 & (0xFF8F)) | TIM_OCMode_Toggle;
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
		TIM1->CCMR1 = ((TIM1->CCMR1) & 0xFF8F) | (TIM_ForcedAction_Active);
		TIM1->CCR1 = 0;
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
		TIM1->CCMR1 = ((TIM1->CCMR1) & 0xFF8F) | (TIM_ForcedAction_InActive);
		TIM1->CCR1 = 0;
		break;
	}

	switch (pconfiguration->ui8SignalStateV) {
	case SIGNAL_STATE_FREQ:
		if (pconfiguration->ui16SignalShiftV > 180) {
			ui32TempCcVal1 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftV - 180) / 180;
			TIM1->CCER |= (TIM_CCER_CC2P | TIM_CCER_CC2NP);
		} else {
			TIM1->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
			ui32TempCcVal1 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftV) / 180;
		}

		TIM1->CCMR1 = (TIM1->CCMR1 & (0x08FFF)) | (TIM_OCMode_Toggle << 8);
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
		TIM1->CCMR1 = ((TIM1->CCMR1) & 0x08FFF) | (TIM_ForcedAction_Active << 8);
		TIM1->CCR2 = 0;
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
		TIM1->CCMR1 = ((TIM1->CCMR1) & 0x08FFF) | (TIM_ForcedAction_InActive << 8);
		TIM1->CCR2 = 0;
		break;
	}

	switch (pconfiguration->ui8SignalStateW) {
	case SIGNAL_STATE_FREQ:
		if (pconfiguration->ui16SignalShiftW > 180) {
			ui32TempCcVal2 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftW - 180) / 180;
			TIM1->CCER |= (TIM_CCER_CC3P | TIM_CCER_CC3NP);
		} else {
			TIM1->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
			ui32TempCcVal2 = TIM_PERIOD_HTL * (pconfiguration->ui16SignalShiftW) / 180;
		}

		TIM1->CCMR2 = (TIM1->CCMR2 & (0xFF8F)) | TIM_OCMode_Toggle;
		break;
	case SIGNAL_STATE_ON:
		TIM1->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
		TIM1->CCMR2 = ((TIM1->CCMR2) & 0xFF8F) | (TIM_ForcedAction_Active);
		TIM1->CCR3 = 0;
		break;
	case SIGNAL_STATE_OFF:
		TIM1->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
		TIM1->CCMR2 = ((TIM1->CCMR2) & 0xFF8F) | (TIM_ForcedAction_InActive);
		TIM1->CCR3 = 0;
		break;
	}

	dSystemGeneratorPeriod(TIM_PERIOD_HTL)
	dSystemGeneratorPrescaler(TIM_PRESCALER_HTL/pconfiguration->ui32SignalFrequencyMaster)
	dSystemGeneratorFrequencies(ui32TempCcVal0, ui32TempCcVal1, ui32TempCcVal2)

}

/* Initialize default parameters */
void vSetDefaultConfiguration() {
	vSetMode(MODE_PWM16Khz);
	vSetShifts(10, 120, 240);
	vSetFrequencies(2, SIGNAL_STATE_OFF, SIGNAL_STATE_OFF, SIGNAL_STATE_OFF);
	vSetAmplitudesAndOffsets(20, 20, 20, 0, 0, 0);

}

/* Response with status*/
void vBuildResponse(uint16_t ui16state, uint8_t ui8error) {

	if (ui16state == CMD_GET_ALL && !ui8error) {
		Configuration_t *pconfiguration = &stcGlobalConfiguration;

		dPutByteIntoQueue(stcQueueTx, (4 + 1 + 4 + 3 + 3 * 6))
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (CMD_GET_ALL >> 8))
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) CMD_GET_ALL);
		// Error status
		dPutByteIntoQueue(stcQueueTx, 0)

		// Mode
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui8SignalMode))

		// Frequency
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui32SignalFrequencyMaster))
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui32SignalFrequencyMaster) >> 8)
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui32SignalFrequencyMaster) >> 16)
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui32SignalFrequencyMaster) >> 24)

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui8SignalStateU))
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui8SignalStateV))
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui8SignalStateW))

		// Shift
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftU));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftU) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftV));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftV) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftW));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalShiftW) >> 8);

		// Amplitude
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeU));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeU) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeV));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeV) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeW));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalAmplitudeW) >> 8);

		// VOffset
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetU));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetU) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetV));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetV) >> 8);

		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetW));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (pconfiguration->ui16SignalOffsetW) >> 8);
	} else {
		dPutByteIntoQueue(stcQueueTx, 5);
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) (ui16state >> 8));
		dPutByteIntoQueue(stcQueueTx, (uint8_t ) ui16state);
		dPutByteIntoQueue(stcQueueTx, ui8error);
		dPutByteIntoQueue(stcQueueTx, 0);

	}
}

void vOnTheFlyConfigurator() {

	if (stcGlobalConfiguration.ui8Update & UPDATE_ALL) {
		dSystemGeneratorEnable(DISABLE);
		switch (stcGlobalConfiguration.ui8Update) {
		case UPDATE_ALL:
			if (stcGlobalConfiguration.ui8SignalMode == MODE_HTL) {
				TIM1->RCR = 1;

				// Timer Clock 50,0 Mhz / Prescaler
				dSystemGeneratorPrescaler(TIM_PRESCALER_HTL)

				// Prescaler value defines the Shift precision
				dSystemGeneratorPeriod(0)
				dSystemGeneratorEnableInterrupt(ENABLE)

			} else {
				TIM1->RCR = 0;

				// Timer 12,5 Mhz!
				dSystemGeneratorPeriod(TIM_PERIOD_PWM)
				if (stcGlobalConfiguration.ui8SignalMode == MODE_STOEBER) {
					dSystemGeneratorPrescaler(MODE_PWM16Khz);
				} else {
					dSystemGeneratorPrescaler(stcGlobalConfiguration.ui8SignalMode)
				}
				dSystemGeneratorEnableInterrupt(ENABLE)
			}

			stcGlobalRuntimeData.ui8Mode = stcGlobalConfiguration.ui8SignalMode;
			// Configure frequency, amp and etc
		default:
			if (stcGlobalConfiguration.ui8SignalMode == MODE_HTL) {
				vSetupHtl();
			} else {
				vSetupPwm();
			}
			stcGlobalConfiguration.ui8Update = UPDATE_NONE;
			break;
		}

		dSystemGeneratorEnable(ENABLE);
	}
}

/* Transmit Data from Tx Queue*/
void vTransmitQueueData() {
	uint16_t ui16Temp;
	uint8_t ui8SingleByte;
	ui16Temp = dGetQueueSize(stcQueueTx);
	if (ui16Temp > 0) {
		if (USARTx_BLOCK->SR & USART_SR_TXE) {
			dRemoveByteFromQueue(stcQueueTx, ui8SingleByte);
			dWrite(ui8SingleByte);
		}
	}
}

/*+++++++++++++++++++++++++++++++++
 * 			Main
 *+++++++++++++++++++++++++++++++++*/
int main(void) {
	uint8_t *pui8CurrentData = NULL;
	uint16_t ui16ParserState = INIT;
	uint16_t ui16RxBufferOffset = 0;
	uint8_t ui8TempRxByteCount;
	uint8_t ui8Length;

	vSystemConfigureMisc();			// Setup Misc
	vSystemConfigureClocks();		// Setup RCC
	vSystemConfigureUart();			// Setup UART

	memset(&stcGlobalConfiguration, 0, sizeof(Configuration_t));			// Reset memory for the configuration in use+
	memset(&stcGlobalRuntimeData, 0, sizeof(RuntimeData_t));
	vSystemSetTicktime(SYSTICK_10HZ);	// 10 Hz

	// Configure Queues for Data Transfer
	vInitQueues();

	vSystemConfigureGenerator();
	vSetDefaultConfiguration();

	while (1) {
		vOnTheFlyConfigurator();
		vTransmitQueueData();

		// State Machine
		// collect Data, allocate Memory, parse Data
		//------------------------------------------------
		ui8TempRxByteCount = dGetQueueSize(stcQueueRx);

		// Parser State Machine
		switch (ui16ParserState) {
		case INIT:

			if (ui8TempRxByteCount > 0) {
				ui16gUartTimeout = TIMEOUT_2SECONDS;	// Timeout is 2 seconds
				dPeekFirstByte(stcQueueRx, ui8Length);

				// if Valid Length: there has ben at least one byte payload
				if (ui8Length >= 4) {
					pui8CurrentData = malloc(ui8Length);	// create a bit of space for length and cmd

					dAssert(pui8CurrentData != NULL);
					++ui16ParserState;
				} else {
					vBuildResponse(ui16ParserState, ERROR_LENGTH);
					dClearQueue(stcQueueRx);
				}
			}
			break;

			// Reception
		case RECEIVE:
			if (ui8TempRxByteCount > 0) {

				// Check how many bytes are left
				// if There are more than we need then we receive only as much as we need
				if (ui8TempRxByteCount >= ui8Length) {
					dRemoveFromQueue(stcQueueRx, pui8CurrentData, ui16RxBufferOffset, ui8Length);
					++ui16ParserState;
					// less bytes than what we need
				} else {
					ui8Length -= ui8TempRxByteCount;
					dRemoveFromQueue(stcQueueRx, pui8CurrentData, ui16RxBufferOffset, ui8TempRxByteCount);
					ui16RxBufferOffset += ui8TempRxByteCount;
				}
			}
			break;

			// Jump to command
		case VALIDATE:
			if (dReceivedCommand(pui8CurrentData) >= CMD_SET_FREQUENCIES) {	// Validate command
				ui16ParserState = dReceivedCommand(pui8CurrentData);
			} else {
				vBuildResponse(ui16ParserState, ERROR_COMMAND);
				ui16ParserState = CLEANUP;
			}
			break;

			// Commands: TODO optimize commom error detection e. g. length
			//------------------------------------------------------------
		case CMD_SET_FREQUENCIES:
			if (dReceivedLength(pui8CurrentData) == (3 + 4 + 3)) {
				vSetFrequencies(*((uint32_t*) &pui8CurrentData[3]), pui8CurrentData[3 + 4], pui8CurrentData[3 + 4 + 1], pui8CurrentData[3 + 4 + 2]);

				vBuildResponse(CMD_SET_FREQUENCIES, ERROR_NONE);
			} else {
				vBuildResponse(CMD_SET_FREQUENCIES, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;
		case CMD_SET_AMPOFFSETS:
			if (dReceivedLength(pui8CurrentData) == (3 + 2 * 3 * 2)) {
				dCriticalSection(
						vSetAmplitudesAndOffsets(*(uint32_t* ) (pui8CurrentData + 3), *(uint32_t* ) (pui8CurrentData + 3 + 2), *(uint32_t* ) (pui8CurrentData + 3 + 4), *(uint32_t* ) (pui8CurrentData + 3 + 6), *(uint32_t* ) (pui8CurrentData + 3 + 8), *(uint32_t* ) (pui8CurrentData + 3 + 10)));
				vBuildResponse(CMD_SET_AMPOFFSETS, ERROR_NONE);
			} else {
				vBuildResponse(CMD_SET_AMPOFFSETS, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;

		case CMD_SET_SHIFTS:
			if (dReceivedLength(pui8CurrentData) == (3 + 2 * 3)) {
				dCriticalSection(vSetShifts(*(uint32_t* ) (pui8CurrentData + 3), *(uint32_t* ) (pui8CurrentData + 3 + 2), *(uint32_t* ) (pui8CurrentData + 3 + 4)));
				vBuildResponse(CMD_SET_SHIFTS, ERROR_NONE);
			} else {
				vBuildResponse(CMD_SET_SHIFTS, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;

		case CMD_MODE:
			if (dReceivedLength(pui8CurrentData) == (4)) {
				dCriticalSection(vSetMode(*(pui8CurrentData + 3)));
				vBuildResponse(CMD_MODE, ERROR_NONE);

			} else {
				vBuildResponse(CMD_MODE, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;

		case CMD_SET_ALL:
			if (dReceivedLength(pui8CurrentData) == (3 + 1 + 4 + 3 + 3 * 6)) {
				dCriticalSection(vSetMode(*(pui8CurrentData + 3));

				vSetFrequencies(*((uint32_t* ) &pui8CurrentData[4]), pui8CurrentData[4 + 4], pui8CurrentData[4 + 4 + 1], pui8CurrentData[4 + 4 + 2]);

				vSetShifts(*((uint16_t* ) &pui8CurrentData[11]), *((uint16_t* ) &pui8CurrentData[11 + 2]), *((uint16_t* ) &pui8CurrentData[11 + 4]));

				vSetAmplitudesAndOffsets( *((uint16_t* ) &pui8CurrentData[17]), *((uint16_t* ) &pui8CurrentData[17 + 2]), *((uint16_t* ) &pui8CurrentData[17 + 4]), *((uint16_t* ) &pui8CurrentData[23]), *((uint16_t* ) &pui8CurrentData[23 + 2]), *((uint16_t* ) &pui8CurrentData[23 + 4])));

				vBuildResponse(CMD_SET_ALL, ERROR_NONE);
			} else {
				vBuildResponse(CMD_SET_ALL, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;

		case CMD_GET_ALL:
			if (dReceivedLength(pui8CurrentData) == (3)) {
				vBuildResponse(CMD_GET_ALL, ERROR_NONE);
			} else {
				vBuildResponse(CMD_GET_ALL, ERROR_LENGTH);
			}
			ui16ParserState = CLEANUP;
			break;

		case CLEANUP:
		default:
			free(pui8CurrentData);
			ui16RxBufferOffset = 0;
			ui16ParserState = INIT;
			pui8CurrentData = NULL;
			break;

		}
		// taking too long, we need to reset the interface and queue
		if (!ui16gUartTimeout && ui16ParserState != INIT) {
			vBuildResponse(ui16ParserState, ERROR_TIMEOUT);
			dClearQueue(stcQueueRx);
			ui16ParserState = CLEANUP;
		}

	}
}

/* Timer for setting timeouts etc*/
void SysTick_Handler(void) {
	if (ui16gUartTimeout > 0) {
		--ui16gUartTimeout;
	}
}

// Use CC Interrupt with preload for PWM
/* Timer Routinen */
void TIM1_UP_TIM10_IRQHandler() {
	static uint32_t ui32ShiftU = 0;
	static uint32_t ui32ShiftV = 0;
	static uint32_t ui32ShiftW = 0;

	static uint16_t ui16CCR1 = 0;
	static uint16_t ui16CCR2 = 0;
	static uint16_t ui16CCR3 = 0;

	uint32_t ui32FrequencyBasedOnPwm;

// Software Floating Point
//-------------------------
// #define PI 3.1415926535f
// uint32_t offset = 0x10;
// uint32_t amp = (COUNTER_MAX>>1)-offset;
// TIM_ClearITPendingBit(TIM1, TIM_IT_Update);
// TIM1->CCR1 = (uint32_t)(amp*sin(2* ui32ConfiguredFrequency*(realstep) * PI)+ amp+offset);
// TIM1->CCR2 = (uint32_t)(( amp*sin(2* ui32ConfiguredFrequency*(realstep) * PI+ 2*PI/3)+ amp+offset));
// TIM1->CCR3 =  (uint32_t)(amp*sin(2* ui32ConfiguredFrequency*(realstep) * PI+ 2*PI*2/3)+ amp+offset);

//realstep = realstep + incrementstep;
//if(realstep>=2){
//	 realstep = 0;
//}

	/*
	 // Number Anzahl der Tastpunkte
	 ui32numberOfPoints = TOTAL_NUM_OF_VALS/(ui32ConfiguredFrequency*ui32IncrementMultiplier);
	 ui32numberOfPointsBetweenPeaks = ui32numberOfPoints/2-2;
	 uin32startingpoint = 1000;
	 ui32endingpoint = 3000;


	 if(ui32numberOfPointsBetweenPeaks>0){

	 }else{
	 // nur peaks
	 }
	 */

// alle signale 120 Grad versetzt zu einander
	/*
	 ui32tempIndex++;


	 if(ui32tempIndex>ui32NumberOfPointsBetweenPeaks){

	 ui32temp = uin32startingpoint;
	 uin32startingpoint = ui32endingpoint;
	 ui32endingpoint = ui32temp;

	 ui32tempIndex=0;
	 }else{

	 }

	 ui32TableIndex = ((uint32_t) (uin32startingpoint+(ui32tempIndex * ui32ConfiguredFrequency*ui32IncrementMultiplier)) % nm_of_increments);


	 if (ui8Select50pDuty) {
	 ui32TableIndex = TOTAL_NUM_OF_VALS / 2;
	 } else {
	 ui32temp = (uint32_t) ((ui32increment) / ui32IncrementMultiplier);
	 ui32TableIndex = (ui32temp) % TOTAL_NUM_OF_VALS;
	 ui32increment = (ui32increment + ui32ConfiguredFrequency * ui32IncrementMultiplier);
	 }



	 ui32TableIndex = (uint32_t) ((ui32Increment) * ui32IncrementMultiplier) % TOTAL_NUM_OF_VALS;
	 ui32Increment = (uint32_t) (ui32Increment + ui32ConfiguredFrequency) % (nm_of_increments );*/

	//ui32DebugArray[ui32DebugIndex] = ui32TableIndex;
	//ui32DebugIndex = (ui32DebugIndex + 1) % 1000;
	//ui32DebugCounter = 0;
	// 977 Werte pro Abschnitt
	++ui32DebugCounter;

	switch (stcGlobalRuntimeData.ui8Mode) {
	case MODE_PWM16Khz:
	case MODE_PWM8Khz:
	case MODE_PWM4Khz:
	case MODE_PWM2Khz:
		if (stcGlobalConfiguration.ui32SignalFrequencyMaster != 0) {
			ui32ShiftU = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftU) % mTotalNumberOfValues;
			ui32ShiftV = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftV) % mTotalNumberOfValues;
			ui32ShiftW = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftW) % mTotalNumberOfValues;

			ui16CCR1 = arrui32SignalTable[ui8SelectSignalType][ui32ShiftU] * stcGlobalConfiguration.ui16SignalAmplitudeU / 100; // + arrui32SignalTable[ui8SelectSignalType][ui32ShiftU] * (100 - stcGlobalConfiguration.ui16SignalAmplitudeU) / 200;
			ui16CCR2 = arrui32SignalTable[ui8SelectSignalType][ui32ShiftV] * stcGlobalConfiguration.ui16SignalAmplitudeV / 100; // + arrui32SignalTable[ui8SelectSignalType][ui32ShiftV] * (100 - stcGlobalConfiguration.ui16SignalAmplitudeV) / 200;
			ui16CCR3 = arrui32SignalTable[ui8SelectSignalType][ui32ShiftW] * stcGlobalConfiguration.ui16SignalAmplitudeW / 100; // + arrui32SignalTable[ui8SelectSignalType][ui32ShiftW] * (100 - stcGlobalConfiguration.ui16SignalAmplitudeW) / 200;

			TIM1->CCR1 = ui16CCR1 + stcGlobalRuntimeData.ui16BottomOffsetU;
			TIM1->CCR2 = ui16CCR2 + stcGlobalRuntimeData.ui16BottomOffsetV;
			TIM1->CCR3 = ui16CCR3 + stcGlobalRuntimeData.ui16BottomOffsetW;

			ui32FrequencyBasedOnPwm = stcGlobalConfiguration.ui32SignalFrequencyMaster;
			if (stcGlobalRuntimeData.ui8Mode == MODE_PWM16Khz) {
				ui32FrequencyBasedOnPwm = ui32FrequencyBasedOnPwm >> 1;	// 1 Hz kann nicht dargestellt werden, bzw bei 16 kHz sind 3 Hz dann 1 Hz
			} else if (stcGlobalRuntimeData.ui8Mode == MODE_PWM4Khz) {
				ui32FrequencyBasedOnPwm = ui32FrequencyBasedOnPwm << 1;
			} else if (stcGlobalRuntimeData.ui8Mode == MODE_PWM2Khz) {
				ui32FrequencyBasedOnPwm = ui32FrequencyBasedOnPwm << 2;
			}

			stcGlobalRuntimeData.ui16TableIndex = (stcGlobalRuntimeData.ui16TableIndex + (ui32FrequencyBasedOnPwm)) % mTotalNumberOfValues;
		} else {
			TIM1->CCR1 = (TIM_PERIOD_PWM * 100) / 170;	//TIM_PERIOD_PWM>>1;
			TIM1->CCR2 = (TIM_PERIOD_PWM * 100) / 180;	//TIM_PERIOD_PWM>>1;
			TIM1->CCR3 = (TIM_PERIOD_PWM * 100) / 180;	//TIM_PERIOD_PWM>>1;
		}
		break;
	case MODE_STOEBER:
		if (stcGlobalConfiguration.ui32SignalFrequencyMaster != 0) {
			ui32ShiftU = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftU) % mTotalNumberOfValues;
			ui32ShiftV = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftV) % mTotalNumberOfValues;
			ui32ShiftW = (stcGlobalRuntimeData.ui16TableIndex + stcGlobalRuntimeData.ui16ShiftW) % mTotalNumberOfValues;

			ui16CCR1 = arrui32SignalTable[dSelectTriangle][ui32ShiftU] * stcGlobalConfiguration.ui16SignalAmplitudeU / 100;
			ui16CCR2 = arrui32SignalTable[dSelectTriangle][ui32ShiftV] * stcGlobalConfiguration.ui16SignalAmplitudeV / 100;
			ui16CCR3 = arrui32SignalTable[dSelectTriangle][ui32ShiftW] * stcGlobalConfiguration.ui16SignalAmplitudeW / 100;

			TIM1->CCR1 = ui16CCR1 + stcGlobalRuntimeData.ui16BottomOffsetU;
			TIM1->CCR2 = ui16CCR2 + stcGlobalRuntimeData.ui16BottomOffsetV;
			TIM1->CCR3 = ui16CCR3 + stcGlobalRuntimeData.ui16BottomOffsetW;

			ui32FrequencyBasedOnPwm = stcGlobalConfiguration.ui32SignalFrequencyMaster >> 1;
			stcGlobalRuntimeData.ui16TableIndex = (stcGlobalRuntimeData.ui16TableIndex + (ui32FrequencyBasedOnPwm)) % mTotalNumberOfValues;

		}

		break;
	default:
		break;
	}

	stcGlobalRuntimeData.ui8Duant = ~stcGlobalRuntimeData.ui8Duant;
	TIM1->SR &= ~TIM_SR_UIF;

}

/* Receive Rx Interrupts*/
void USART3_IRQHandler() {

	// Is there is new data, put it into queue
	// Bit is cleared by reading DR
	if (USART3->SR & USART_SR_RXNE) {
		dPutByteIntoQueue(stcQueueRx, USART3->DR);
	}
}

